*** DRY ***
DRY - Don't repeat yourself.
- У нас существует единый источник истины.
- У нас нет повторяющихся блоков/модулей кода.

Пример из React:
У нас 2 одинаковых блока кода.
const Main = (props) => {
  return (
    <>
      <div>
        <p>Item 1</p>
        <button>item1 click</button>
      </div>
      <div>
        <p>Item 2</p>
        <button>item2 click</button>
      </div>
    </>
  );
};
Нам необходимо выносить эти модули в отдельный компонент, который принимает пропсы.
const CustomComponent = ({ name, buttonName }) => {
  return (
    <div>
      <p>${name}</p>
      <button>${buttonName}</button>
    </div>
  )
}
После всех действий, мы просто используем непосредственно компоненты.
const Main = (props) => {
  return (
    <>
      <CustomComponent name={"Item 1"} buttonName={"item1 cllick"} />
      <CustomComponent name={"Item 2"} buttonName={"item2 cllick"} />
    </>
  );
};
*** KISS ***
KISS - Keep it short and simple.
- Не добавлять ненужные методы или фитчи.
- Создавать всё максимально лёгким путём.
*** SOLID ***
S - Single Responsibility Principle.
Каждый класс должен отвечать за один аспект(решать одну поставленную задачу).
O - Open Close Principle.
Классы, объекты должны быть открыты для расширения и закрыты для изменений.
L - Liskov Substitution Principle.
Принцип подстановки Лисков гласит, что любой класс должен быть заменяем на свой родительский класс без неожиданных последствий.
I - Interface Segregation Principle.
Принцип разделения интерфейсов гласит, что слишком "толстые" интерфейсы должны быть разделены на более мелкие и специфические 
интерфейсы, так что программные сущности более мелких интерфейсов знают только о методах, которые им нужны. В результате, 
изменение метода интерфейса не должно изменять программные сущности, которые не используют этот метод.
D - Dependency Inversion Principle.
A. Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций.
B. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.
*** YAGNI ***
YAGNI - You are not gonna need it.
Главный посыл этого принципа это "Избегание избыточной функциональности приложения."
*** Императивное программирование ***
Императивное программирование - концепт этого программирования создание алгоритма в программах, который меняет состояние 
программы.
*** Декларативное программирование ***
Декларативное программирование - концепт этого программирования описание финального результата без создания алгоритмов.
Пример:
Я хочу приготовить ужин.
Императивное программирование:
- необходимо купить продукты
- необходимо порезать мясо, использовать соус.
- необходимо вымыть овощи и порезать их.
- необходимо всё перемешать и пожарить. Потом потушить 20-30 минут.
Декларативное программирование:
- Я хочу тушёные овощи с мясом на ужин.
Помимо этих типов существуют парадигмы ООП и ФП.
*** HTTP ***
HTTP - HyperText Transfer Protocol, это абстрактноуровневый протокол, функции HTTP основаны на запрос-ответ концептах 
в клиент-серверной архитектуре.
Методы запросов:
OPTIONS - используется для объявления серверных особенностей или опций для соединения к какому-либо источнику.
GET - получение объекта или объектов.
GET /api/users/55
POST - содание новых объектов.
POST /api/users/
PUT - полное изменение объектов.
PUT /api/users/55
PATCH - частичное изменение объектов.
PATCH /api/users/55
DELETE - удаление конкретного объекта.
DELETE /api/users/55
HEAD - выполнить какое-либо действие.
HEAD /api/logout
TRACE - в ответе возвращается информация, что сервер изменил или добавил.
*** HTTPS ***
HTTPS - HyperText Transfer Protocol Secure, HTTP протокол расширен для поддержки шифрования для лучшей безопасности.
*** HTTP Headers ***
Всего есть 4 группы http заголовков:
General Headers - могут содержаться в серверных или клиентских сообщениях.
Request Headers - используют только в клиентских запросах.
Response Headers - используют только в серверных запросах.
Entity Headers - сопровождают каждый объект сообщения.
*** Status Codes ***
1xx - информация
2xx - успех транзакции
3xx - редирект
4xx - ошибки на клиенте
5xx - ошибки на сервере
Примеры:
200 - успешный запрос
400 - неверная дата в запросе 
401 - неавторизованный доступ
404 - отсутствия пути
405 - метод запроса не поддерживается
500 - ошибка сервера
507 - переполнение хранилища
527 - достижение таймаута
*** TCP vs UDP ***
TCP - Transport Control Protocol, протокол, которому необходимо соединение между двумя хостами. У этого протокола хорошая
безопасность, потому что через него не происходит потерь передаваемых данных запрашивает подтверждение получения у принимающих
данные и, при необходимости отправляет данные повторно Сегменты отправляемых данных сохраняют порядок отправки. Основоной 
проблемой является скорость отправки данных.
UDP - User Datagram Protocol, является более простым протоколом. При передаче данных не требуется устанавливать соединение между 
отправителем и получателем. Информация передается без предварительной проверки готовности принимающей стороны. Это делает 
протокол менее надежным - некоторые фрагменты данных могут быть потеряны во время передачи. Кроме того, не соблюдается порядок 
следования данных - возможен непоследовательный прием данных получателем. С другой стороны, скорость передачи данных по этому 
транспортному протоколу будет выше.
*** CORS ***
CORS - Cross-Origin Resource Sharing, это механизм безопасности, который использует HTTP-заголовки для предоставления пользователю
возможности разрешить доступ из некоторых источников.
*** JSON ***
JSON - JavaScript Object Notation, это формат данных, который имеет собственный независимый стандарт и библиотеки для большинства 
языков программирования.
Форматы запросов:
Простой текст, json, FormData
*** AJAX ***
AJAX - Asynchronous Javascript And Xml, это технология запроса без перезагрузки страницы. 
AJAX - это не только XML, AJAX - это действия с сервером без перезагрузки страницы, которые организуются с помощью JavaScript.
AJAX очень полезен при работе с некоторыми формами и кнопками.
*** Fetch Api ***
FetchApi - интерфейс для получения некоторых источников, таких как XMLHttpRequest. Fetch Api более гибкий и мощный.
Первый аргумент fetch - url, второй - опции.
fetch() возвращает обещание
*** SSE ***
Спецификация Server-Sent Events описывает встроенный класс EventSource, который позволяет поддерживать соединение с сервером 
и получать от него события. Как и в случае с WebSocket, соединение постоянно.

Но есть несколько важных различий:

WebSocket                                                             |	 EventSource
Двунаправленность: и сервер, и клиент могут обмениваться сообщениями  |	Однонаправленность: данные посылает только сервер
Бинарные и текстовые данные	                                          |  Только текст
Протокол WebSocket	                                                  |   Обычный HTTP

EventSource не настолько мощный способ коммуникации с сервером, как WebSocket. Зачем нам его использовать?
Основная причина: он проще. Многим приложениям не требуется вся мощь WebSocket.

*** Long Poling ***
Длинные опросы – это самый простой способ поддерживать постоянное соединение с сервером, не используя при этом никаких 
специфических протоколов (типа WebSocket или Server Sent Events). Его очень легко реализовать, и он хорошо подходит для 
многих задач. Они также очень просты в реализации, и сообщения доставляются без задержек. 
Как это происходит:
1. Запрос отправляется на сервер.
2. Сервер не закрывает соединение, пока у него не возникнет сообщение для отсылки.
3. Когда появляется сообщение – сервер отвечает на запрос, посылая его.
4. Браузер немедленно делает новый запрос.

*** Методологии разработки ПО ***

Code and fix — модель кодирования и устранения ошибок;
Waterfall Model — каскадная модель, или «водопад»;
V-model — V-образная модель, разработка через тестирование;
Incremental Model — инкрементная модель;
Iterative Model — итеративная (или итерационная) модель;
Spiral Model — спиральная модель;
Chaos model — модель хаоса;
Prototype Model — прототипная модель.

Самые популярные: Waterfall, V-model, Incremental, Iterative, Spiral.

1) Waterfall:

В этой модели всё идёт поэтапно.
первый этап -> второй -> третий

Преимущества Waterfall:
- Разработку достаточно просто контролировать. Заказчик всегда знает, 
чем сейчас заняты программисты
- Стоимость проекта определяется на начальном этапе.
Недостатки Waterfall:
- Исправление ошибок стоять дорого.
- Заказчик видит результат в конце разработки и только тогда может дать обратную связь.
- Разработчики пишут много документации, это задерживает работу.

При работе с Waterfall основная задача - написать подробные требования к разработке.

2) V-model:

Это усовершенствованный тип от Waterfall, где заказчик с командой программистов одновременно 
составвляют требования к системе и описывают тесты на каждом этапе.

Преимущества V-model:
- Количество ошибок в архитектуре ПО сводится к минимуму
Недостатки V-model:
- Если при разработке архитектуры была допущена ошибка, то она будет дорогой как в Waterfall

V-model подходит для проектов, в которых важна надёжность и цена ошибки очень высока.

3) Incremental Model

Это модель разработки по частям.
Ситуация: Заказчик решил запустить соцсеть. Создали соцсеть и её основные функции. После этого
разработка идёт по частям, добавление функционала и т.д..

Преимущества Incremental:
- Не нужно вкладывать много денег на начальном этапе.
- Можно получить фидбек от пользователей и обновить какой-то функционал.
- Ошибки обходятся дешевле.
Недостатки Incremental:
- Каждая команда программистов разрабатывает свою функциональность и может реализовать интерфейс
продукта по своему.
- Разработчкики буду оттягивать доработку основной функциональности и будут делать мелкие правки.

4) Iterative Model

Это модель, при которой заказчик не обязан понимать, какой продукт хочет получить в итоге,
и может не прописывать сразу подробное техзадание.

Преимущества Iterative Model:
- Быстрый выпуск минимального продукта.
- Постоянное тестирование пользователями.
Недостатки Iterative Model:
- Отсутствие фиксированного бюджета.
- Использование на начальном этапе баз данных или серверов приходиться переделывать так как
их сложно масштабировать, а вторые не выдерживают нагрузки.

Итеративная модель подходит для работы над большими проектами с неопределёнными требованиями,
либо для задач с инновационным подходом, когда заказчик не уверен в результате. 

5) Spiral Model

Используя эту модель заказчик и команда разработчиков серёзно анализируют риски проекта и вы-
полняют его итерациями. Итерации основыеваются на предыдущие итерации и принимается решение про-
должать проект или нет.

Преимущества Spiral Model:
- Большое время уделяется проработке рисков.
Недостатки Spiral Model:
- Застрять на начальном этапе - бесконечно совершенствовать первую версию продукта.
- Разработка длится долго и дорого.

Agile - подход к разработке. Включает в себя практики, подходы и методологии.

экстремальное программирование (Extreme Programming, XP);
бережливую разработку программного обеспечения (Lean);
метология для управления проектами Scrum;
разработку, управляемую функциональностью (Feature-driven development, FDD);
разработку через тестирование (Test-driven development, TDD);
методологию «чистой комнаты» (Cleanroom Software Engineering);
итеративно-инкрементальный метод разработки (OpenUP);
методологию разработки Microsoft Solutions Framework (MSF);
метод разработки динамических систем (Dynamic Systems Development Method, DSDM);
метод управления разработкой Kanban.

Например, Scrum чаще называют не методологией, а фреймворком. В чём разница? Фреймворк — 
это более сформированная методология со строгими правилами. В скраме все роли и процессы
чётко прописаны. Помимо Scrum, часто используют Kanban. 

Kanban
Сегодня это одна из наиболее популярных методологий разработки ПО.
Команда ведёт работу с помощью виртуальной доски, которая разбита на этапы проекта.
Каждый участник видит, какие задачи находятся в работе, какие — застряли на одном из
этапов, а какие уже дошли до его столбца и требуют внимания. 

В отличие от скрама, в канбане можно взять срочные задачи в разработку сразу,
не дожидаясь начала следующего спринта. 
Канбан удобно использовать не только в работе, но и в личных целях — распределять
собственные планы или задачи семьи на выходные, наглядно отслеживать прогресс.

*** Git ***
1) Конфигурация Git

Уровни конфигураций:

--system
--global ищет в --global потом в --system
--local (default) сначала ищет config local потом -global

git config user.name 'Oleg'

git config --global -e  - открыть редактирование файла конфигураций

.gitattributes - конфиг файл для работы с атрибутами в проекте.

.gitignore - конфиг файл, в котором шаблоны директориев на которые git не образает внимание.

git check-ignore -v srcipts/for/one - проверяет среди всех шаблонов .gitignore проходит
такой путь или нет.

2) Основы Git 

git add . - внести все изменения
git status - посмотреть статус изменений
git commit -m 'коммит меседж' - коммит
git show - посмотреть детали коммита

комит без add

gitcommit -am 'Some commit' - не трогает новые файлы
alias.commitall '!git add .; git commit' создание алиаса

git rm <paths> - удаление файла
git rm -r src - удаление директории src
git mv index.html hello.html - переименование файла index.html -> hello.html

3) Ветки

git branch feature - создание новой ветки
git checkout feature - переходим на ветку

git branch -v - вывести состояние веток и последний коммит.

git checkout --force master - незакомиченные изменения будут утеряны
git stash - можно временно сохранить изменения перед тем как идти на другую ветку
git stash pop - вытащить эти изменения

git branch -f master коммитхэш/ветка - для того, чтобы ветка мастер 
перешла на старый коммит.

git branch -d fix - удаление ветки
git branch -D fix

git reflog master - логи ветки master
git reflog --date=iso

git gc - удалит недостяжимые коммиты

4) Теги Git

git tag v1.0.0 1943 - тег просто метка, он никуда не перемещается и указывает на один коммит.
git show --quiet v1.0.0

git tag - список тегов
git tag --contains 1943 - посмотреть список тегов, которые содержат коммит 1943

чтобы удалить Теги пишем

git tag -d название тегов - удаление тегов

git describe - найти ближайший тег

5) Reset в Git

git reset идентификатор коммита или '@~2'(на два коммита назад) - откатить на коммит
--hard
git reset --hard cvDqw1
git reset --hard ORIG_HEAD - вернуть всё как было, если нас не устроил ресет.
git reset --hard HEAD
--soft
git reset --soft cvDqw1
git commit --amend - правка последнего коммита. Откат ветки назад и создание нового коммита с
этими изменениями.
--mixed
git reset @~ - mixed - ресет по умолчанию.
--keep
git reset --keep - при жёстком reset, все незакоммиченные изменения удаляются, а keep старается
их сохранить. Reset --keep - это тот же жёсткий reset, но с сохранением незакоммиченных изменений.
--merge
git reset --merge - отмена неудачного конфликтного слияния.

6) Очистка проекта от изменений

git clean -dxf - удаление всех неотслеживаемых файлов и директорий.

7) Git просмотр

git diff master feature - сравнение коммитов.
git diff master...feature - если мы хотим узнать, что изменилось в feature 

8) Git слияние

git merge master - слияние ветки с master
git merge --abort
для отката слияния: 
git reset --hard @~ - если допустим хотим отменить merge и вернуться на предыдущий коммит.

Merge Strategy:
* recursive
* octopus
* ours 
* resolve
* subtree

9) Копирование коммитов.

git cherry-pick commit - копирование коммитов, делает с помощью cherry-pick
git cherry-pick --abort - отменит черипик и вернёт коммиты.
git cherry-pick --quit - прекращаем выполнение черипик.


10) Перемещение коммитов.

git rebase master - перемещение нашей ветки в мастер.
git rebase --abort
git rebase --quit

другой вариант записи:
git rebase --onto master feature - говорим, что мы хотим перебазировать ветку на мастер и ука-
зываем с какого момента.

11) Обратные коммиты.

git revert - делает коммит с противоположенными изменениями, для отмены коммита.

*** Patterns ***

- Проверенные решения. Вы тратите меньше времени, используя готовые решения, вместо повторного 
изобретения велосипеда. До некоторых решений вы смогли бы додуматься и сами, но многие могут 
быть для вас открытием.

Классификация паттернов:

* Порождающие паттерны беспокоятся о гибком создании объектов без внесения в программу 
лишних зависимостей.

* Структурные паттерны показывают различные способы построения связей между объектами.

* Поведенческие паттерны заботятся об эффективной коммуникации между объектами.

Порождающие:

1.Одиночка(Singleton) - это порождающий паттерн проектирования, который гарантирует, у класса 
есть только один экземпляр, и предоставляет к нему глобальную точку доступа. Одиночка решает
сразу две проблемы, нарушая принцип еднственной ответственности класса. Нарушает SOLID - Single
responsibility principle, так как является God object.

1) Гарантирует наличие единственного экземпляра класса.
2) Предоставляет глобальную точку доступа.

Обычно одиночки не имеют глобального конструктора, который можно получить. Вместо этого обычно у
одиночки есть метод(интерфейс), вызвав который можно получить данные.
Одиночку никогда не заменит другой код, существует только один экзмепляр этого клсса.

Плюсы:
- Гарантирует наличие единственного экземпляра класса.
- Предоставляет к нему глобальную точку доступа.
Минусы:
- Нарушает SOLID
- Маскирует плохой дизайн.

2.Строитель(Builder) - это порождающий паттерн проектирования, который позволяет создавать 
сложные объекты пошагово. Строитель даёт возможность использовать один и тот же код строительства
для получения разных представлений объектов.

Сам паттерн предлагает разделить процесс на подпроцессы и создать объект строитель для каждого
подпроцесса. Чтобы полностью создать объект, нам придётся вызывать поочерёдно вызовы строите-
лей. Часто бывает, что нам необходимо несколько вызывать вариантов стрителей, в зависимости от
поставленной задачи. Мы с лёгкостью может добавить вариативных строителей и вынести их вызовы
в отдельный класс, Директор. В этом случае директор будет заниматься вызовами строителей, 
строитель будет их выполнять. Получится отличный сплит обязанностей.
Такая структура будет будет скрывать полностью процесс конструирования объектов.

Плюсы:
- Поэтапное создание продукта.
- Переиспользование одного и того же кода.
- Изолирует код реализации от кода сборки.
Минусы:
- Усложняет код программы из-за введения дополнительный классов.

3.Фабричный метод - это порождающий паттерн проектирования, который определяет общий интерфейс 
для создания объектов в суперклассе, позволяя подклассам изменять тип создаваемых объектов.

Паттерн Фабричный метод предлагает создавать объекты не напрямую, используя оператор new, а 
через вызов особого фабричного метода. Не пугайтесь, объекты всё равно будут создаваться при 
помощи new, но делать это будет фабричный метод.

4.Абстрактная фабрика — это порождающий паттерн проектирования, который позволяет создавать 
семейства связанных объектов, не привязываясь к конкретным классам создаваемых объектов.

Для начала паттерн Абстрактная фабрика предлагает выделить общие интерфейсы для отдельных 
продуктов, составляющих семейства. Так, все вариации кресел получат общий интерфейс Кресло, 
все диваны реализуют интерфейс Диван и так далее. Далее вы создаёте абстрактную фабрику — 
общий интерфейс, который содержит методы создания всех продуктов семейства (например, 
создатьКресло, создатьДиван и создатьСтолик). Эти операции должны возвращать абстрактные 
типы продуктов, представленные интерфейсами, которые мы выделили ранее — Кресла, Диваны и 
Столики. Как насчёт вариаций продуктов? Для каждой вариации семейства продуктов мы должны 
создать свою собственную фабрику, реализовав абстрактный интерфейс. Фабрики создают продукты 
одной вариации. Например, ФабрикаМодерн будет возвращать только КреслаМодерн,ДиваныМодерн и 
СтоликиМодерн. Клиентский код должен работать как с фабриками, так и с продуктами только через 
их общие интерфейсы. Это позволит подавать в ваши классы любой тип фабрики и производить любые 
продукты, ничего не ломая.

5.Прототип — это порождающий паттерн проектирования, который позволяет копировать объекты, не 
вдаваясь в подробности их реализации. 

Паттерн Прототип поручает создание копий самим копируемым объектам. Он вводит общий интерфейс 
для всех объектов, поддерживающих клонирование. Это позволяет копировать объекты, не привязываясь к их конкретным классам. 

Структурные:

1.Адаптер(Adapter) - паттерн основанный на преобразовании объектов к единому виду, для 
совместной работы. Адаптер - очень полезен, он выступает в качестве объекта переводчика 
и трансформирует интерфейс или данные одного объекта в такой вид, чтобы он стал понятен 
другому объекту.
Бывает также двухсторонний адаптер, который трансформирует в обе стороны. Допустим у нас есть
данные одного формата XML и нам надо привести всё к формату JSON. Адаптер отлично выполнит эту
работу. 

Плюсы:
- Отделяет и скрывает от клиента подробности преобразования различных интерфейсов.
Минусы:
- Усложняет код программы из-за введения дополнительных классов.

2.Заместитель(Proxy) - это структурный паттер, который позволяет подставлять вместо реальных 
объектов специальные объекты-заменители. Эти объекты перехватывают вызовы к оригинальному
объекту, позволяя что-то сделать до или после передачи вызова оригиналу.
С помощью этого паттерна можно с лёгкостью добавить какой-нибудь дополнительный слой логики.

Плюсы:
- Позволяет контролировать сервисный объект незаметно для клиента.
- Может работать, даже если сервисный объект ещё не создан.
- Может контролировать жизненный цикл служебного объекта.
Минусы:
- Усложняет код программы из-за введения дополнительных классов.
- Увеличивает время отклика от сервиса.

3.Мост — это структурный паттерн проектирования, который разделяет один или несколько классов 
на две отдельные иерархии — абстракцию и реализацию, позволяя изменять их независимо друг от друга.

4.Компоновщик — это структурный паттерн проектирования, который позволяет сгруппировать множество 
объектов в древовидную структуру, а затем работать с ней так, как будто это единичный объект.

5.Декоратор — это структурный паттерн проектирования, который позволяет динамически добавлять объектам 
новую функциональность, оборачивая их в полезные «обёртки».

Декоратор имеет альтернативное название — обёртка. Оно более точно описывает суть паттерна: вы помещаете 
целевой объект в другой объект-обёртку, который запускает базовое поведение объекта, а затем добавляет к 
результату что-то своё.

6.Фасад — это структурный паттерн проектирования, который предоставляет простой интерфейс к сложной системе 
классов, библиотеке или фреймворку.

Фасад — это простой интерфейс для работы со сложной подсистемой, содержащей множество классов. Фасад может 
иметь урезанный интерфейс, не имеющий 100% функциональности, которой можно достичь, используя сложную подсистему 
напрямую. Но он предоставляет именно те фичи, которые нужны клиенту, и скрывает все остальные.

7.Легковес — это структурный паттерн проектирования, который позволяет вместить бóльшее количество объектов в 
отведённую оперативную память. Легковес экономит память, разделяя общее состояние объектов между собой, вместо 
хранения одинаковых данных в каждом объекте.

Поведенческие:

1.Наблюдатель(Observer) - это поведенческий паттерн, который создаёт механизм подписки, позволя-
ющий одним объектам следить и реагировать на события, происходящие в других объектах.

Сам по себе объект Observer должен подписывать кого-то на события. После этого с объектом, у 
которого подписка выполняются какие-либо действия.

Пример из жизни:
После того как вы оформили подписку на газету или журнал, вам больше не нужно ездить в 
супермаркет и проверять, не вышел ли очередной номер. Вместо этого издательство будет 
присылать новые номера по почте прямо к вам домой сразу после их выхода.

Издательство ведёт список подписчиков и знает, кому какой журнал высылать. Вы можете в 
любой момент отказаться от подписки, и журнал перестанет вам приходить.

Плюсы:
- Издатели не зависят от конкретных классов подписчиков и наоборот.
- Вы можете подписывать и отписывать получателей на лету.
- Реализует принцип открытости/закрытости.

Минусы:
- Подписчики оповещаются в случайном порядке.

2.Состояние(State) - это поведенческий паттерн проектирования, который позволяет объектам менять
поведение в зависимости от своего состояния. Извне создаётся впечатление, что изменился класс 
объекта.

Плюсы:
- Избавляет от множества больших условных операторов машины состояний.
- Концентрирует в одном месте код, связанный с определённым состоянием.
- Упрощает код контекста.
Минусы:
- Может неоправданно усложнить код, если состояний мало и они редко меняются.

3.Цепочка обязанностей — это поведенческий паттерн проектирования, который позволяет передавать 
запросы последовательно по цепочке обработчиков. Каждый последующий обработчик решает, может ли он 
обработать запрос сам и стоит ли передавать запрос дальше по цепи.

4.Команда — это поведенческий паттерн проектирования, который превращает запросы в объекты, позволяя 
передавать их как аргументы при вызове методов, ставить запросы в очередь, логировать их, а также поддерживать
отмену операций.

5.Итератор — это поведенческий паттерн проектирования, который даёт возможность последовательно обходить элементы 
составных объектов, не раскрывая их внутреннего представления.

6.Посредник — это поведенческий паттерн проектирования, который позволяет уменьшить связанность множества классов 
между собой, благодаря перемещению этих связей в один класс-посредник.

7.Снимок — это поведенческий паттерн проектирования, который позволяет сохранять и восстанавливать прошлые состояния 
объектов, не раскрывая подробностей их реализации.

8.Стратегия — это поведенческий паттерн проектирования, который определяет семейство схожих алгоритмов и помещает 
каждый из них в собственный класс, после чего алгоритмы можно взаимозаменять прямо во время исполнения программы.

9.Шаблонный метод — это поведенческий паттерн проектирования, который определяет скелет алгоритма, перекладывая 
ответственность за некоторые его шаги на подклассы. Паттерн позволяет подклассам переопределять шаги алгоритма, 
не меняя его общей структуры.

10.Посетитель — это поведенческий паттерн проектирования, который позволяет добавлять в программу новые операции, 
не изменяя классы объектов, над которыми эти операции могут выполняться.

*** Структуры данных, алгоритмы поиска, сортировки, сложность алгоритма ***

1.Связный список — базовая динамическая структура данных в информатике, состоящая из узлов, каждый из которых содержит 
как собственно данные,так ссылку («связку») на следующий узел списка. Данная структура позволяет эффективно добавлять 
и удалять элементы на произвольной позиции в последовательности в процессе итерации. Более сложные варианты включают 
дополнительные ссылки, позволяющие эффективно добавлять и удалять произвольные элементы.

2.Двойной связный список

3.Очередь (англ. queue) - структура данных в информатике, в которой элементы хранятся в порядке их добавления. Добавление
новых элементов(enqueue) осуществляется в начало списка. А удаление элементов (dequeue) осуществляется с конца. 
Таким образом очередь реализует принцип "первым вошёл - первым вышел" (FIFO). Часто реализуется операция чтения 
головного элемента (peek), которая возвращает первый в очереди элемент, при этом не удаляя его. Очередь является 
примером линейной структуры данных или последовательной коллекции.

4.Стек (англ. stack — стопка) — абстрактный тип данных, представляющий собой список элементов, организованных по принципу 
LIFO (последним пришёл — первым вышел).

5.Хеш-таблица - структура данных, реализующая абстрактный тип данных ассоциативный массив, т.е. структура, которая 
связывает ключи со значениями. Хеш-таблица использует хеш-функцию для вычисления индекса в массиве, в котором может быть найдено желаемое значение.

6.Граф - абстрактный тип данных, который должен реализовывать концепции направленного и ненаправленного графа в математике, особенно в области теории графов.
Структура данных графа состоит из конечного (и возможно изменяющегося) набора вершин или узлов, или точек, совместно с набором 
ненаправленных пар этих вершин для ненаправленного графа или с набором направленных пар для направленного графа. Эти пары известны как рёбра, арки или линии 
для ненаправленного графа и как стрелки, направленные рёбра, направленные арки или направленные линии для направленного графа. Эти вершины могут быть частью 
структуры графа, или внешними сущностями, представленными целочисленными индексами или ссылками.

7.Дерево — одна из наиболее широко распространённых структур данных в информатике, эмулирующая древовидную структуру в виде набора связанных узлов. 
Является связным графом, не содержащим циклы. Большинство источников также добавляют условие на то, что рёбра графа не должны быть ориентированными. 
В дополнение к этим трём ограничениям, в некоторых источниках указывается, что рёбра графа не должны быть взвешенными.

8. Куча — это специализированная структура данных типа дерево, которая удовлетворяет свойству кучи: если B является узлом-потомком узла A,
то ключ(A) ≥ ключ(B). Из этого следует, что элемент с наибольшим ключом всегда является корневым узлом кучи, поэтому иногда такие кучи называют max-кучами.

Таблица по алгоритмам:

**********************************************************************************************
1. Bubble Sort:
   Time Complexity : Best => O(n) , Worst & Average => O(n*n)
   Space Complexity: O(1) 
   Stablitiy       : Stable
   Is-In-Place     : In-Place	
   When to use     : 1. If array is of small size 
		               2. If array is of large size but nearly sorted
   Remark          : Easiest to implement	
**********************************************************************************************
2. Cocktail, Shaker Sort (Modification of Bubble Sort):
   Time Complexity : Best => O(n) , Worst & Average => O(n*n)
   Space Complexity: O(1) 
   Stablitiy       : Stable
   Remark          : Modification of Bubble sort
**********************************************************************************************
3. Odd-Even Sort (Modification of Bubble Sort):
   Time Complexity : Best => O(n) , Worst => O(n*n)
   Space Complexity: O(1) 
   Stablitiy       : Stable
   Remark          : Modification of Bubble sort
**********************************************************************************************
4. Comb Sort (Modification of Bubble Sort):
   Time Complexity : Best => O(n*logn) , Worst => O(n*n)
   Space Complexity: O(1) 
   Stablitiy       : Stable
   Remark          : Variation of Bubble sort
**********************************************************************************************
5. Selection Sort:
   Time Complexity : Best & Worst & Average => O(n*n)
   Space Complexity: O(1) 
   Stablitiy       : Not-Stable
   Is-In-Place     : In-Place
   When to use     : 1. If array is of small size
		               2. To minimise the number of swaps
   Remarks         : Bubble sort has more number of swaps as compare to selection
		             Sort but bubble sort has better best time complexity.
		             It can also be implemented as stabaly.
		             Selection sort makes O(n) swaps which is minimum among all sorting algorithms mentioned above.	
**********************************************************************************************
6. Insertion Sort:
   Time Complexity : Best => O(n) , Worst & Average => O(n*n)
   Space Complexity: O(1) 
   Stablitiy       : Stable
   Is-In-Place     : In-Place
   When to use     : 1. If array is of small size and nearly sorted
   Remark          : Standard Libraray of C uses this algo when n becomes smaller
		             than a threshold and for small size it is better than merge
		             and quick sort becasue of low constant values and non
 		             recusive in nature.
**********************************************************************************************
7. Heap Sort:
   Time Complexity : Best & Worst & Average => O(nLog(n))
   Space Complexity: O(1) 
   Stablitiy       : Not-Stable
   Is-In-Place     : In-Place
   When to use     : When the input array is large and stable sort is not 
                     required.		
   Remark          : It always guaranteed to be O(nLog(n)) with constant space 
                     which solves the problem of overflow of address space of a 
                     process which may occur in merge and quick sort(recursive stack).
**********************************************************************************************
8. Counting Sort:
   Time Complexity : Best & Worst & Average => O(n+k)
   Space Complexity: O(n+k) 
   Stablitiy       : Not-Stable
   Is-In-Place     : In-Place
**********************************************************************************************
9. Merge Sort:
   Time Complexity : Best & Worst & Average => O(nLog(n))
   Space Complexity: O(n) 
   Stablitiy       : Stable 
   Is-In-Place     : Not-In-Place
   Tag             : Divide & Conquer
   When to use     : 1.When we don't have random access(linked list)
                      [R.A like as we have in array]
                     2.When array is not to large.
**********************************************************************************************
10. Quick Sort:
   Time Complexity : Best => O(nLog(n)) , Worst => O(n*n) 
   Space Complexity: O(n) 
   Stablitiy       : Not-Stable 
   Is-In-Place     : In-Place
   Tag             : Divide & Conquer
   When to use     : 1.It is prefered over merge sort for extremely large array
                     2.When you don't care about worst case complexity
----------------------------------------------------------------------------------------------

*** Unit-tests ***

Юнит-тестирование - это процесс, который позволяет контролировать некоторые программные модули с 
помощью тестов. Основная идея этой концепции - быстрая проверка новых изменений кода.
Библиотеки на JavaScript, которые помогают нам тестировать: Jest, Enzyme, RTL(React Testing Library). 
С помощью тестов мы пытаемся проверить некоторые специфические случаи поведения программы.

Пирамида тестирования:
	-----------
	     UI - самые долгие и нестабильные тесты
     -----------------
      Интеграционные
	/Api тесты - более громозкие тесты чем Unit тесты
  -----------------------
        Unit тесты - быстрые тесты, простые, стабильные и точные
---------------------------

*** Оценка скорости приложения - Google Lighthouse ***

Привести пример

*** Прототипное наследование ***

Наследование по прототипу является концепцией чейнинг наследования в JavaScript.
Самый высокий уровень в этой иерархии - это объект объект, а __proto__ объекта - null.
Если у нас нет метода, мы поднимаемся выше по структуре чейна и пытаемся найти его в прототипах.
У нас есть возможность перезаписать или добавить некоторые пользовательские методы.
__proto__ ES6
Object.getPrototypeOf() ES5

__proto__ - это свойство есть у всех объектов. Нам необходимо знать с помощью какой функции -
конструктора создан данный объект. ССЫЛАЕТСЯ НА PROTOTYPE КЛАССА/ФУНКЦИИ КОНСТРУКТОРА, С ПОМОЩЬЮ
КОТОРОГО ЭТОТ ОБЪЕКТ БЫЛ СОЗДАН!!!

prototype - это свойство, которое есть у функций и классов, этого свойства нет у стрелочных функций.
Сам по себе прототип - это независимый объект с определённым набором свойств и методов.

*** Типы данных (приведение) ***
Все типы:
1) Number -> primitive type
2) String -> primitive type
3) Boolean -> primite type
4) Object -> object type
5) BigInt -> primitive type 
6) Symbol -> primitive type
7) undefined -> primitive type
8) null -> primitive type, but typeof null === "object", an old bug of JavaScript

Все typeof типы:
1) "number"
2) "string"
3) "boolean"
4) "undefined"
5) "object"
6) "function"
7) "symbol"
8) "bigint"

Примитивные типы взаимодействуют по значению, а объектные по ссылкам.
Самые странные кейсы:
{} + [] и [] + {}

в первом случае {} + [], 
{} это пустой блок кода, поэтому у нас остётся +[]
+[] это конвертирование в number, +[] === 0
поэтому, в первом случае {} + [] === 0

во втором случае [] + {}
массив [] приводится к строке, [].toString() === ""
"" + {} === "[objectObject]"
поэтому, во втором случае получается "[objectObject]"

Ещё странные примеры
массивы:
[].toString() === ""
[1,2].toString() === "1,2"
[1, "abc"].toString() === "1, abc"
+[] === 0
+[1] === 1
+[1, 2] === NaN
!![] === true

объекты:
let obj = {}
obj.toString() === "[objectObject]"
+obj === NaN
!!obj === true 

*** Всплытие (Hoisting) ***
Всплытие - это механизм в JavaScript, когда объявление переменных через var, функций и классов
поднимается вверх по скоупу, но тем не менее классы мы не можем использовать до объявления.

*** Замыкание ***
Замыкание в JavaScript - это комбинация функции и лексическсого окружения. Функция зависит от 
значений лексического окружения. Лексическое окружение = родительская область видимости. 
Родительская область видимости может быть глобальной областью видимости или 
функцией/локальным/блоком.

пример:

function sum(number) {
	return function(secondNumber) {
		return number + secondNumber
	}
}

const addFive = sum(5) // замкнули значение 5
const addTen = sum(10) // замкнули значение 10
const addTwo = sum(2) // замкнули значение 2
const result_1 = addFive(10) // 15
const result_2 = addTen(100) // 110
const result_3 = addTwo(55) // 57

function example2() {
	let variable = 0
	return function() {
		return variable++
	}
}

const exec = example2();
console.log(exec()) // 0
console.log(exec()) // 1
console.log(exec()) // 2
console.log(exec()) // 3

*** Контекст ***

Контекст соединяется с объектом. Ключевое слово "this" связывается с объектом, которому 
принадлежит функция. Основная проблема с контекстом - потеря контекста. 
Call, bind, apply, new - это типы связывания контекста в JavaScript.

*** Event Loop, способы выполнения асинхронного кода ***

Цикл событий является движком асинхронности в JavaScript. В структуре цикла событий есть 
memory heap, call stack, webApi и call queue.

Приоритеты задач:
Sync Task
В Node "Nanotask" не называется, но имеет больший приоритет, чем Microtask. process.nextTick
Микрозадачи, например Promises
Макротаски, например, setTimeout

*** Function Expression / Declaration, IIFE ***

Regular Functions vs Arrow Functions

1. this
2. arguments
3. constructor (стрелочные функции не могут быть функциями конструкторами)

*** Операторы и выражения, циклы в JS ***

логические операторы или ||, и &&, ! отрицание.

|| - находит первое истинное значение.
&& - находит первое ложное значение.

операторы присваивания
операторы сравнения
арифметические операторы
строковые операторы
условный (тернарный) оператор

*** Регулярные выражения, RegExp ***
Конструктор RegExp создаёт объект регулярного выражения для сопоставления текста с шаблоном.

const regex1 = /\w+/;
const regex2 = new RegExp('\\w+');

методы test, match

regexObj.test(str) - сопоставление со строкой, возвращает true или false

Метод match() возвращает получившиеся совпадения при сопоставлении строки с регулярным 
выражением.

*** Методы Object, Object.prototype ***

assign - используется для копирования объекта.
create - создаёт новый объект с указанным прототипом и свойствами.
entries - метод возвращает массив собственных перечисляемых свойств указанного 
объекта в формате [key, value].
keys -  возвращает массив значений перечисляемых свойств объекта.

*** Методы Array, Array.prototype ***

map, forEach, filter, find, findIndex, concat, join, push, pop, reduce, slice, splice, sort,
reverse

*** Методы Function.prototype ***

apply, call, bind, lenght, name

*** Promise *** 

Promise - это механизм для ассинхронных действий. 

Promise может находиться в трёх состояниях:

- ожидание (pending): начальное состояние, не исполнен и не отклонён.
- исполнено (fulfilled): операция завершена успешно.
- отклонено (rejected): операция завершена с ошибкой. 

new Promise((reject, resolve) => { // стоят перепутанными местами
	setTimeout(resolve, 2000) 
	setTimeout(reject, 3000)
})
	.then(() => console.log('1')) // у нас первый выполнится catch, этот then не отработает
  	.catch(() => console.log('2')) // первый вывод
  	.then(console.log('1')) // это вообще будет отдельной синхронной таской
	.then(3) // это обычное проваливание, так как у нас не передан коллбэк
	.then(() => 5) // колбэк возвращает значение 5, res = 5
	.finally(() => console.log('finally')) // отработает корректно
	.then((res) => console.log(res)) // выведет 5, если напишем так .then(() => console.log(res))
произойдёт срабатывание catch
	.catch(() => console.log('4')) // не отработает

Вывод:
1, 2, finally, 5

Показать:

new Promise((reject, resolve) => {
	setTimeout(resolve, 2000)
	setTimeout(reject, 3000)
})
	.then(() => console.log('1'))
  	.catch(() => console.log('2'))
  	.then(console.log('1'))
	.then(3)
	.then(() => 5)
	.finally(() => console.log('finally'))
	.then((res) => console.log(res))
	.catch(() => console.log('second catch'))

*** HTML, CSS (несколько вопросов, на усмотрение) ***

HTML (HyperText Markup Language) - стандартизированный язык разметки документов для 
просмотра веб-страниц в браузере.

структура HTML:

первая строка - <!DOCTYPE html> - это строка служит указателем для браузера,
что у нас документ формата html, можно написать xml.

далее идёт обёртка в теге <html lang="en"></html>, которая имеет свои атрибуты,
например lang, title, manifest.

в html теге присутствует 2 блока <head></head> и <body></body>

<head></head> - блок предназначен для заголовка страницы и технической информации.
внутри <head></head> допускается размещать элементы <link>, <meta>, <script>, <style>, <title>.

<body></body> - блок предназначенный для размещения того, что мы хотим увидеть на странице.
Весь наш контент располгается там. Мы можем размещать информацию вида текст, изображения, теги,
скрипты JavaScript и т.д. Часто тег body используется для размещения обработчика событий, например:
onload.

data-attribute -  Вспомогательный атрибут, позволяющий ссылаться на элемент или его данные.

CSS (Cascading Style Sheets) -  формальный язык описания внешнего вида документа (веб-страницы), написанного 
с использованием языка разметки (чаще всего HTML или XHTML). CSS используется создателями веб-страниц для задания 
цветов, шрифтов, стилей, расположения отдельных блоков и других аспектов представления внешнего вида этих веб-страниц.

display (CSS) определяет тип отображения элемента, имеющий два основных свойства, определяющих генерацию 
боксов — внешний тип отображения определяет расположение бокса и внутренний тип отображения определяет расположение 
дочерних элементов бокса
display: block;
display: inline;
display: flex;
display: grid;

position указывает, как элемент позиционируется в документе.
position бывает relative, absolute, fixed либо sticky

Относительно позиционируемый элемент это элемент с position relative. 
Свойства top и bottom определяют смещение по вертикали от его нормального положения; свойства left и right 
задают горизонтальное смещение.

Абсолютно позиционируемый элемент — это элемент с position absolute или fixed. top, 
right, bottom и left задают смещения от краёв содержащего блок элемента. (Содержащий блок является предком, 
относительно которого расположен элемент.) Если элемент имеет поля, они добавляются к смещению. Элемент устанавливает 
новый контекст форматирования блока (BFC) для своего содержимого.

Элемент с липкой позицией — это элемент c position sticky. Он рассматривается 
как относительно позиционированный до тех пор, пока содержащий его блок не пересечёт указанный порог (например, установка 
top в значение, отличное от auto) внутри его корня потока (или в контейнере, в котором он прокручивается), после чего он 
обрабатывается как «застрявший» до тех пор, пока не встретит противоположный край содержащего его блока.

Таблица приоритетности селекторов.
вес селекторов 
1) !import
2) inline style
3) combined selectors
4) ID
5) class
6) attribute
7) element
8) *
9) inherited styles

the strongest comination of selectors is !import + inline styles

Псевдоклассы в CSS

selector:pseudo-class {
  property: value
}

There are a lot of pseudo-classes
Some of them:
:active
:checked
:disabled
:first
:first-child
:focus
:hover
:nth-child
:visited

Вес селектора считается 
X, X, X, X
style="", - инлайн стили
#id, - идентификаторы
.class, - классы, атрибуты и псевдоклассы
<tag> - теги и псевдоэлементы

Если вес двух селекторов, применяемых к одному элементу ОДИНАКОВЫЙ, то применяется последний
объявленный.

*** DOM ***

DOM (Document Object Model) - HTML/XML документы представлены в браузере в виде DOM-дерева.
- Теги становятся узлами-элементами и формируют структуру документа.
- Текст становится текстовыми узлами.
- Всё, что записано в HTML, есть и в DOM-дереве, даже комментарии.

Для изменения элементов или проверки DOM-дерева мы можем использовать инструменты разработчика в браузере.
Все операции с DOM начинаются с document.

Получив DOM-узел, мы можем перейти к его ближайшим соседям используя навигационные ссылки.
Есть два основных набора ссылок:

- Для всех узлов: parentNode, childNodes, firstChild, lastChild, previousSibling, nextSibling.
- Только для узлов-элементов: parentElement, children, firstElementChild, lastElementChild, 
previousElementSibling, nextElementSibling.

Есть 6 основных методов поиска элементов в DOM:

Метод	           Ищет по...	           Ищет внутри элемента?	Возвращает живую коллекцию?
querySelector	      CSS-selector	             ✔	                          -
querySelectorAll      CSS-selector	             ✔	                          -
getElementById	          id	                      -	                          -
getElementsByName	 name	                      -	                          ✔
getElementsByTagName	tag or '*'	              ✔	                          ✔
getElementsByClassName	 class	                      ✔	                          ✔
Живая коллекция - эта так, с которой мы можем взаимодействовать. 
Безусловно, наиболее часто используемыми в настоящее время являются методы querySelector и querySelectorAll, 
но и методы getElement(s)By* могут быть полезны в отдельных случаях, а также встречаются в старом коде.

*** `use strict` ***

Режим strict, введённый в ECMAScript 5, позволяет использовать более строгий вариант JavaScript. 
Это не просто подмножество языка: в нем сознательно используется семантика, отличающаяся от обычно принятой.

Строгий режим принёс ряд изменений в обычную семантику JavaScript. Во-первых, строгий режим заменяет исключениями 
некоторые ошибки, которые интерпретатор JavaScript ранее молча пропускал. Во-вторых, строгий режим исправляет ошибки, 
которые мешали движкам JavaScript выполнять оптимизацию -- в некоторых случаях код в строгом режиме может быть оптимизирован 
для более быстрого выполнения, чем код в обычном режиме. В-третьих, строгий режим запрещает использовать некоторые 
элементы синтаксиса, которые, вероятно, в следующих версиях ECMAScript получат особый смысл.

чтобы использовать строгий режим нужно написать 'use strict'

"use strict";
                      // Предполагая, что не существует глобальной переменной
mistypeVaraible = 17; // mistypedVaraible, эта строка выбросит ReferenceError
                      // из-за опечатки в имени переменной

"use strict";
delete Object.prototype; // выдаст TypeError

function sum(a, a, c) { // !!! синтаксическая ошибка
  "use strict";
  return a + a + c; // ошибка, если код был запущен
}

В большинстве браузеров в настоящее время строгий режим реализован.

*** Теги srcipt, аттрибуты async, defer ***

<script> - это секция для JavaScript кода. Эта секция зависит от позиции в html документе. После секции <script> мы не можем 
помещать html, который зависит от JavaScript кода. Решение этой проблемы перемещение <script> в конец тега <body>, но в 
этом случае у людей с плохим интернетом будут подвисания. У нас есть defer и async атрибуты для <script>. Эти скрипты 
выполняются на заднем плане. defer зависит от места в body. async зависит от скорости скачивания.

      |      The order of execution            |     DOMContentLoaded
async | Нет порядка выполнения.                | Не важно. Может скачиваться и запускаться 
      | Первый скачанный скрипт, выполняется   | перед загрузкой страницы. Это обычно происходит, когда
      | первым.                                | скрипты достаточно маленькие, а документ достаточно большой.
defer | Есть порядок выполнения. Порядок       | Выполняются после того как документ загрузился и обработан, 
      | определяется тем, как расположен в     | перед DOMContentLoaded.
      | документе.                             |

*** Event Handling ***

Событие – это сигнал от браузера о том, что что-то произошло. 
Все DOM-узлы подают такие сигналы (хотя события бывают и не только в DOM).

События мыши:

click – происходит, когда кликнули на элемент левой кнопкой мыши (на устройствах с сенсорными 
экранами оно происходит при касании).
contextmenu – происходит, когда кликнули на элемент правой кнопкой мыши.
mouseover / mouseout – когда мышь наводится на / покидает элемент.
mousedown / mouseup – когда нажали / отжали кнопку мыши на элементе.
mousemove – при движении мыши.

События на элементах управления:

submit – пользователь отправил форму <form>.
focus – пользователь фокусируется на элементе, например нажимает на <input>.
Клавиатурные события:

keydown и keyup – когда пользователь нажимает / отпускает клавишу.

События документа:

DOMContentLoaded – когда HTML загружен и обработан, DOM документа полностью построен и доступен.

Событию можно назначить обработчик, то есть функцию, которая сработает, как только событие произошло.
Именно благодаря обработчикам JavaScript-код может реагировать на действия пользователя.
Есть несколько способов назначить событию обработчик. Сейчас мы их рассмотрим, начиная с самого 
простого.

- Использование атрибута HTML
Обработчик может быть назначен прямо в разметке, в атрибуте, который называется on<событие>.
<input value="Нажми меня" onclick="alert('Клик!')" type="button">

- Использование свойства DOM-объекта
Можно назначать обработчик, используя свойство DOM-элемента on<событие>.

К примеру, elem.onclick:

<input id="elem" type="button" value="Нажми меня!">
<script>
  elem.onclick = function() {
    alert('Спасибо');
  };
</script>

Назначить более одного обработчика событий таким способом нельзя.
Разработчики стандартов достаточно давно это поняли и предложили альтернативный способ назначения 
обработчиков при помощи специальных методов addEventListener и removeEventListener. 
Они свободны от указанного недостатка.

element.addEventListener(event, handler[, options]);
element.removeEventListener(event, handler[, options]);
event - имя события, например "click".
handler - ссылка на функцию-обработчик.
options - дополнительный объект со свойствами.

Чтобы хорошо обработать событие, могут понадобиться детали того, что произошло. Не просто «клик» 
или «нажатие клавиши», а также – какие координаты указателя мыши, какая клавиша нажата и 
так далее.

Когда происходит событие, браузер создаёт объект события, записывает в него детали и 
передаёт его в качестве аргумента функции-обработчику.

пример input, в котором мы берём event.targetValue

Мы можем назначить обработчиком не только функцию, но и объект при помощи addEventListener. В этом случае, когда происходит событие, вызывается метод объекта handleEvent.

К примеру:

<button id="elem">Нажми меня</button>

<script>
  elem.addEventListener('click', {
    handleEvent(event) {
      alert(event.type + " на " + event.currentTarget);
    }
  });
</script>

Всплытие и погружение

Стандарт DOM Events описывает 3 фазы прохода события:

Фаза погружения (capturing phase) – событие сначала идёт сверху вниз.
Фаза цели (target phase) – событие достигло целевого(исходного) элемента.
Фаза всплытия (bubbling stage) – событие начинает всплывать.

Всплытие - это когда на каком-либо элементе происходит событие, обработчики сначала 
срабатывают на нём, потом на его родителе, затем выше и так далее, вверх по цепочке предков.

Для того, чтобы остановить эффект всплытия используется event.stopPropagation(). После того
как мы добавим его. Событие не будет распространяться дальше.

Чтобы поймать событие на стадии погружения, нужно использовать третий аргумент capture вот так:

elem.addEventListener(..., {capture: true})
// или просто "true", как сокращение для {capture: true}
elem.addEventListener(..., true)
Существуют два варианта значений опции capture:

Если аргумент false (по умолчанию), то событие будет поймано при всплытии.
Если аргумент true, то событие будет перехвачено при погружении.

*** Глобальный объект window ***
window — это глобальный объект предоставляемый браузером, внутри которого содержатся все встроенные в браузерный JavaScript 
функции и свойства. window хранит в себе множество объектов и функций: DOM(Document Object Model), BOM(Browser object model), 
JavaScript

DOM - это объект document.
BOM - это массив объектов screen, navigator, history, frames, location, fetch
JavaScript - Object, Function, Array и т.д. 

примеры window.alert, window.console.log, window.setTimeout.
их очень много.

*** Способы отправки запроса на сервер ***

1) Скрипт - скрипт в котором происходит выполнение запроса на сервер.
2) Fetch - fetch api через которые мы также может выполнять запросы на сервер.
3) XmlHTTPRequest - это встроенный в браузер объект, который даёт возможность делать запросы к серверу без перезагрузки страницы.
4) Form - делать запросы через форму.
5) Линка - также по сути является элементом, который делает GET запрос для получения страницы.

*** Кэширование(как работает и зачем нужно) ***

Производительность веб-сайтов и приложений можно значительно повысить за счёт повторного использования ранее полученных ресурсов. 
Веб-кеши сокращают задержку и снижают сетевой трафик, уменьшая тем самым время, необходимое для отображения ресурсов. Используя 
HTTP-кеширование, сайты становятся более отзывчивыми.

Техника кеширования заключается в сохранении копии полученного ресурса для возврата этой копии в ответ на дальнейшие запросы. 
Запрос на ресурс, уже имеющийся в веб-кеше, перехватывается, и вместо обращения к исходному серверу выполняется загрузка копии 
из кеша. Таким образом снижается нагрузка на сервер, которому не приходится самому обслуживать всех клиентов, и повышается 
производительность — кеш ближе к клиенту и ресурс передаётся быстрее. Кеширование является основным источником повышения 
производительности веб-сайтов.

Существует 2 типа кэшей:

- Приватный кеш браузера
Приватный кеш предназначен для отдельного пользователя.Он используется для доступа к ранее загруженным страницам при навигации 
назад/вперёд, позволяет сохранять страницы, или просматривать их код, не обращаясь лишний раз к серверу. Кроме того, 
кеш полезен при отключении от сети.

- Общий прокси-кэш
Кеш совместного использования — это кеш, который сохраняет ответы, чтобы их потом могли использовать разные пользователи. 
Например, в локальной сети вашего провайдера или компании, может быть установлен прокси, обслуживающий множество пользователей,
 чтобы можно было повторно использовать популярные ресурсы, сокращая тем самым сетевой трафик и время ожидания.

управление кешированием происходит с помощью заголовка Cache-control

Cache-Control: no-store - полное отсутствие кэширования
Cashe-Control: no-cashe - кэшировать, но проверять актуальность
Cache-Control: private - приватные 
Cache-Control: public - обще кэши
Cache-Control: max-age=31536000 - срок действия
Сache-Control: must-revalidate - проверка актуальности

*** Что такое React? Преимущества реакта? ***

React - это UI библиотека, которая несёт в себе компонентный подход. Перечислить плюсы React(JSX, Virtual DOM)

*** JSX ***

JSX - JavaScript и XML. Это комбинация синтаксиса HTML и JavaScript. Это синтаксический сахар. Под капотом это 
конструкция React.createElement с (type of element | props | children).

*** Fragment ***

React.Fragment - это способ обернуть несколько элементов вместе без создания блока div. 
Это очень полезный способ обернуть несколько элементов, если нам не нужен блок div с некоторыми стилями.
<React.Fragment></React.Fragment> || короткий способ <></>

У <React.Fragment></React.Fragment> есть атрибут key, у <></> его нет.

*** Виды компонентов (контролируемые и неконтролируемые) ***

Сегодня у нас есть компоненты классов и функций.

Неконтролируемые компоненты похожи на HTML-формы. Они запоминают, что вы ввели. После этого вы можете получить 
его значение, используя ссылку. Некотролируемый компонент — это такой компонент, где ваши данные формы 
обрабатываются в DOM, а не внутри вашего компонента.

Управляемые компоненты получают собственное значение в виде prop и callback для изменения этого prop. Компоненты 
становятся управляемыми, когда вы используете их значение и изменяете его. Контролируемый компонент — это такой 
компонент, где React осуществляет контроль и является единственным источником правды для данных формы.

*** Способы обновления компонента ***

- Компоненты класса: this.setState(), this.forceUpdate()
setState -> изменяет состояние компонента.
forceUpdate -> вызывает метод render() компонента, который пропускает shouldComponentUpdate().
- Функциональные компоненты useState, useReducer
useState -> [value, setValue] -> с помощью setValue мы можем изменить состояние компонента, после чего произойдет рендеринг.
useReducer -> [state, dispatch] -> с помощью dispatch мы можем изменить состояние компонента и вызвать рендеринг.

*** setState ***

SetState - это механизм компонентов класса, который позволяет нам изменять значение состояния. У setState есть опциональный
колбэк, который будет срабатывать после вызова этого setState.

*** Virtual DOM ***

Virtual DOM - концепция представления пользовательского интерфейса, с которой можно взаимодей-
ствовать с DOM без таких сильных затрат.

Current tree - это наше актуальное дерево компонентов.

Current tree -> Rendering Environment

Для отрисовки текущих изменений отвечает Rendering Environment.

Наше дерево Current tree попадает в Rendering Environment. После этого происходят изменения в 
Work in current tree. Допустим пользователь удалил или добавил что-то с помощью такого механизма,
как Reconciliation мы сравниваем Current tree и Work in progress tree ищем различия и отрисовы-
ваем Work in progress tree.

*** Fiber ***

Fiber - В его основе лежит механизм, который отслеживает изменения состояния и отображает обновленное состояние на экране. 
Фактически, мы знаем этот процесс как согласование/reconciliation. 

Можно думать о fiber ноде как о структуре данных, которая представляет собой некоторую работу, или, другими словами, единицу работы. Архитектура fiber также обеспечивает удобный способ отслеживания, планирования, приостановки и прерывания работы. React выполняет работу в два основных этапа: render и commit.

Если это первый рендер, React создает новую fiber ноду для каждого элемента, возвращаемого из рендер метода. В следующих 
обновлениях fiber ноды для существующих элементов React используются повторно и обновляются. Результатом фазы является дерево 
fiber нод, отмеченных побочными эффектами. Эффекты описывают работу, которая должна быть выполнена в следующей commit фазе. 

Планирование - это процесс, который определяет когда работа должна быть выполнена.
Приоритезация - планировщик использует поле приоритета чтоб найти следующую единицу работы которую можно выполнить.

у каждого элемента существует приоритет работы.

export const FunctionComponent = 0;
export const ClassComponent = 1;
export const IndeterminateComponent = 2; // Before we know whether it is function or class
export const HostRoot = 3; // Root of a host tree. Could be nested inside another node.
export const HostPortal = 4; // A subtree. Could be an entry point to a different renderer.
export const HostComponent = 5;
export const HostText = 6;
export const Fragment = 7;
export const Mode = 8;
export const ContextConsumer = 9;
export const ContextProvider = 10;
export const ForwardRef = 11;
export const Profiler = 12;
export const SuspenseComponent = 13;
export const MemoComponent = 14;
export const SimpleMemoComponent = 15;
export const LazyComponent = 16;


*** Life cycle ***

  mount
  methods: 
  constructor(props)
  getDerivedStateFromProps(props, state)
  render()
  componentDidMount()
  -----
  update
  methods:
  getDerivedStateFromProps(props, state)
  shouldComponentUpdate(nextProps, nextState)
  render()
  getSnapshotBeforeUpdate(prevProps, prevState)
  componentDidUpdate(prevProps, prevState, snapshot)
  -----
  unmount
  methods:
  componentWillUnmount()
  -----
  errorhandling
  methods:
  getDerivedStateFromError(error)
  componentDidCatch(error, info)

[UNSAFE_]componentWillMount (устарел)
[UNSAFE_]componentWillReceiveProps (устарел)
[UNSAFE_]componentWillUpdate (устарел)  

*** Hooks ***

useState - хук для инициализации состояния компонента. При деструктуризации нам нужно инициализировать переменную и сеттер 
для этой переменной. const [value, setValue] = useState(initialState)
useRef - хук для создания ссылки-объекта, которую мы можем использовать с некоторыми элементами. Ссылка будет тем же 
объектом после рендеринга. const newRef = useRef(initialValue)
newRef.current.focus()
useContext - хук для использования значений, которые были созданы с помощью React.const someContext = createContext(Context)
Если мы хотим получить его, нам нужно использовать 
<Context.Provider value={someContext}>.
  <ParentComponent />
</Context.Provider

function ParentComponent() {
  здесь мы можем использовать хук useContext, чтобы получить значение Context
  или внутри компонентов
  const myContext = useContext(Context)  
}

useEffect - мутации, подписки, таймеры, логи и другие побочные эффекты мы не можем делать внутри основного тела функционального
 компонента. Это приведет к ошибкам в пользовательском интерфейсе. useEffect(callback, [dependencies]). По умолчанию после каждого
 рендера будут запускаться эффекты. Но мы можем запускать их только при изменении зависимостей. Часто эффекты создают ресурсы, 
которые нам нужно удалить. Если нам это нужно, мы можем использовать функцию return внутри обратного вызова useEffect. 

*** Error boundary ***

Предохранители - это компоненты React, которые отлавливают ошибки JavaScript в любом месте деревьев их дочерних компонентов, 
сохраняют их в журнале ошибок и выводят запасной UI вместо рухнувшего дерева компонентов.

Предохранители отлавливают ошибки при рендеринге, в методах жизненного цикла и конструкторах деревьвев компонентов.
Они не отловят ошибки:
* В обработчиках событий
* В асинхронном коде
* В серверном рендеринге
* В самом предохранителе

Компонент является предохранителем, если он содержит getDerivedStateFromError или componentDidCatch.

Предохранители работают как JavaScript-блоки catch, но только для компонентов.
Только классовые компоненты могут выступать в роли предохранителей. Обычно один раз описывают предохранитель, а потом 
постоянно его используют по коду.

В режиме разработки React 16 выводит на консоль сообщения обо всех ошибках, возникших при рендеринге, даже если они 
никак не сказались на работе приложения. Предохранители не отлавливают ошибки, произошедшие в обработчиках событий.
Чтобы отловить ошибку в обработчике событий, пользуйтесь обычной JavaScript-конструкцией try / catch.


*** componentDidCatch ***

componentDidCatch(error, errorInfo) - используется при написании кода для журналирования информации об отловленной ошибке.

*** getDerivedStateFromError ***

getDerivedStateFromError(error) - используется при рендеринге запасного UI в том случае, если поймает ошибку.

this.state = { hasError: false }

static getDerivedStateFromError(error) {
    // Обновить состояние с тем, чтобы следующий рендер показал запасной UI.
    return { hasError: true };
}

render() {
	if (this.state.hasError) {
		// какой-то запасной UI для ошибки
	} else {
		// обычный UI
	}
}

*** React.PureComponent ***

React.PureComponent - это один из методов оптимизации. React.PureComponent реализует shouldComponentUpdate() его поверхностным 
сравнением пропсов и состояние. shouldComponentUpdate() делает поверхностное сравнение объектов, если они содержат сложные 
структуры данных, это может привести к неправильной работе.

*** React.memo ***

React.memo - HOС. Если ваш компонент всегда рендерит одно и то же при неменяющихся пропсах, вы можете обернуть его в вызов 
React.memo для повышения производительности в некоторых случаях, мемоизируя тем самым результат. Это значит, что React будет 
использовать результат последнего рендера, избегая повторного рендеринга. По умолчанию используется поверностное сравнение props. 
Для контроля сравнения используется кастомная функция, которая передаётся в качестве второго аргумента.

*** useCallback ***

useCallback - хук для оптимизации, который возвращает мемоизированный колбэк. Передаём в хук колбэк и массив зависимостей. 
Когда зависимость меняется, то создаётся новый мемоизированный колбэк. Это полезно при передачи мемо колбэков оптимизированным 
дочерним компонентам, которые полагаются на равенство ссылок, чтобы избежать ненужных рендеров.


*** useMemo ***

useMemo - хук для оптимизации, который возвращает мемоизированное значение. Повторное вычисление мемоизированного значения будет 
в случае изменения зависимостей.


*** HOC ***

HOC. Компонент высшего порядка (Higher-Order Component, HOC) — это один из продвинутых способов для повторного использования логики.
HOC не являются частью API React, но часто применяются из-за композиционной природы компонентов. Компонент высшего порядка — это функция, 
которая принимает компонент и возвращает новый компонент.

* Не мутируйте оборачиваемый компонент.
* Передавайте посторонние пропсы оборачиваемому компоненту.
* Максимизируйте композитвность.

Пример HOC:
withRouter(react-router-dom)
connect(redux)

Мы можем создавать композициии из HOC. Для того чтобы обернуть наш  компонент сразу несколькими слоями функциональности. 
withRouter(connect(MyComponent)). Можем создать функцию compose, которая будет делать композицию из HOC.

*** Render props ***
Render props. Компонент с рендер-пропом берёт функцию, которая возвращает React-элемент, и вызывает её вместо реализации 
собственного рендера.
рендер-проп — функция, которая сообщает компоненту что необходимо рендерить.
Важно запомнить, что из названия паттерна «рендер-проп» вовсе не следует, что для его использования вы должны обязательно 
называть проп render. На самом деле, любой проп, который используется компонентом и является функцией рендеринга, технически 
является и «рендер-пропом».

Использование рендер-пропа может свести на нет преимущество, которое даёт React.PureComponent, если вы создаёте функцию внутри 
метода render. Это связано с тем, что поверхностное сравнение пропсов всегда будет возвращать false для новых пропсов и каждый 
render будет генерировать новое значение для рендер-пропа.

*** Conditional Rendering ***

Conditional Rendering. React позволяет разделить логику на независимые компоненты. Эти компоненты можно показывать или 
прятать в зависимости от текущего состояния. Условный рендеринг в React работает так же, как условные выражения работают в 
JavaScript. Бывает нужно объяснить React, как состояние влияет на то, какие компоненты требуется скрыть, а какие — отрендерить, 
и как именно. В таких ситуациях используйте условный оператор JavaScript или выражения подобные if.

Вы можете внедрить любое выражение в JSX, заключив его в фигурные скобки. Это правило распространяется и на логический оператор 
&& языка JavaScript, которым можно удобно вставить элемент в зависимости от условия.


*** useHistory ***

useHistory()

Хук useHistory предоставляет доступ к истории. Вы можете использовать ее для навигации.
const myHistory = useHistory()
myHistory.goBack()

history - это объект (history Api), который имеет полезные методы и свойства для навигации. История является мутабельной.

*** useLocation ***

Хук useLocation возвращает объект location, который представляет собой текущий URL. Местоположение представляет собой место, 
где сейчас находится приложение.
const myLocation = useLocation()
myLocation.pathname

*** useParams ***

Хук useParams возвращает объект пар ключ/значение параметров URL. 
Пусть { someParam } = useParams();
После этого мы можем выполнить некоторые действия с этим someParam.

*** Switch ***

Switch - это инструмент, который отображает первый маршрут или перенаправление, соответствующее местоположению. Дочерними 
элементами <Switch> должны быть элементы <Route> или <Redirect>. Будет отображен только первый дочерний элемент, соответствующий 
текущему местоположению. 

*** Route ***

Route - это компонент, который отображает некоторый пользовательский интерфейс, когда путь совпадает с текущим URL.

*** connect ***

connect - HOC, который соединяет компонент React и Redux Store. Он предоставляет своему подключенному компоненту части данных, 
которые ему нужны из store, и функции, которые он может использовать для dispatch действий в store. Он не изменяет переданный ему
 компонент. Вместо этого он возвращает новый, связанный компонент, который оборачивает переданный вам компонент.

connect(mapStateToProps?, mapDispatchToProps?, mergeProps?, options?)
Параметры:
У connect 4 разных параметра и все опциональные.
1. mapStateToProps?: Function
2. mapDispatchToProps?: Function | Object
3. mergeProps?: Function
4. options?: Object

mapStateToProps?: (state, ownProps?) => Object
Если функция mapStateToProps описана, то компонент подписывается на изменения State. Это значит, что mapStateToProps вызывается каждый раз, когда store обновляется.
mapStateToProps возвращает объект, в котором мы вытаскиваем свойства из store.

mapDispatchToProps?: Object | (dispatch, ownProps) => Object
mapDispatchToProps - это либо объект либо функция. Если всё таки функция, то она принимает dispatch и возвращает объект, с планируемыми для выполнения actions.

*** provider ***
provider - <Provider/> компонент, которым мы оборачиваем наше приложение для того, чтобы нам стал доступен store из Redux. Все внутренние компоненты получают 
доступ к store. Обычно Provider выносят на верхний уровень.

Props:
store - Redux Store. Единый Redux store в нашем прлиожении.
children - ReactElement. Корень нашкй иерархии компонентов.
context - Есть возможеость передавать сущность context. 

*** useSelector ***

useSelector - Позволяет нам вытащить какую-либо дату из Redux store.
	const result: any = useSelector(selector: Function, equalityFn?: Function)
	Этот хук эквивалентен mapStateToProps.  

	props:
	selector: Function,
	equalityFn?: Function

useSelector() по умолчанию использует строгую === проверку ссылочного равенства, а не shallow equality. Используйте функцию shallowEqual из React-Redux 
в качестве аргумента equalityFn или Lodash's _.isEqual() или Immutable.js сравнения.























