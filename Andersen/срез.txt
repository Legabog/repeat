Методологии разработки ПО

Code and fix — модель кодирования и устранения ошибок;
Waterfall Model — каскадная модель, или «водопад»;
V-model — V-образная модель, разработка через тестирование;
Incremental Model — инкрементная модель;
Iterative Model — итеративная (или итерационная) модель;
Spiral Model — спиральная модель;
Chaos model — модель хаоса;
Prototype Model — прототипная модель.

Самые популярные: Waterfall, V-model, Incremental, Iterative, Spiral.

1) Waterfall:

В этой модели всё идёт поэтапно.
первый этап -> второй -> третий

Преимущества Waterfall:
- Разработку достаточно просто контролировать. Заказчик всегда знает, 
чем сейчас заняты программисты
- Стоимость проекта определяется на начальном этапе.
Недостатки Waterfall:
- Исправление ошибок стоять дорого.
- Заказчик видит результат в конце разработки и только тогда может дать обратную связь.
- Разработчики пишут много документации, это задерживает работу.

При работе с Waterfall основная задача - написать подробные требования к разработке.

2) V-model:

Это усовершенствованный тип от Waterfall, где заказчик с командой программистов одновременно 
составвляют требования к системе и описывают тесты на каждом этапе.

Преимущества V-model:
- Количество ошибок в архитектуре ПО сводится к минимуму
Недостатки V-model:
- Если при разработке архитектуры была допущена ошибка, то она будет дорогой как в Waterfall

V-model подходит для проектов, в которых важна надёжность и цена ошибки очень высока.

3) Incremental Model

Это модель разработки по частям.
Ситуация: Заказчик решил запустить соцсеть. Создали соцсеть и её основные функции. После этого
разработка идёт по частям, добавление функционала и т.д..

Преимущества Incremental:
- Не нужно вкладывать много денег на начальном этапе.
- Можно получить фидбек от пользователей и обновить какой-то функционал.
- Ошибки обходятся дешевле.
Недостатки Incremental:
- Каждая команда программистов разрабатывает свою функциональность и может реализовать интерфейс
продукта по своему.
- Разработчкики буду оттягивать доработку основной функциональности и будут делать мелкие правки.

4) Iterative Model

Это модель, при которой заказчик не обязан понимать, какой продукт хочет получить в итоге,
и может не прописывать сразу подробное техзадание.

Преимущества Iterative Model:
- Быстрый выпуск минимального продукта.
- Постоянное тестирование пользователями.
Недостатки Iterative Model:
- Отсутствие фиксированного бюджета.
- Использование на начальном этапе баз данных или серверов приходиться переделывать так как
их сложно масштабировать, а вторые не выдерживают нагрузки.

Итеративная модель подходит для работы над большими проектами с неопределёнными требованиями,
либо для задач с инновационным подходом, когда заказчик не уверен в результате. 

5) Spiral Model

Используя эту модель заказчик и команда разработчиков серёзно анализируют риски проекта и вы-
полняют его итерациями. Итерации основыеваются на предыдущие итерации и принимается решение про-
должать проект или нет.

Преимущества Spiral Model:
- Большое время уделяется проработке рисков.
Недостатки Spiral Model:
- Застрять на начальном этапе - бесконечно совершенствовать первую версию продукта.
- Разработка длится долго и дорого.

Agile - подход к разработке. Включает в себя практики, подходы и методологии.

экстремальное программирование (Extreme Programming, XP);
бережливую разработку программного обеспечения (Lean);
метология для управления проектами Scrum;
разработку, управляемую функциональностью (Feature-driven development, FDD);
разработку через тестирование (Test-driven development, TDD);
методологию «чистой комнаты» (Cleanroom Software Engineering);
итеративно-инкрементальный метод разработки (OpenUP);
методологию разработки Microsoft Solutions Framework (MSF);
метод разработки динамических систем (Dynamic Systems Development Method, DSDM);
метод управления разработкой Kanban.

Например, Scrum чаще называют не методологией, а фреймворком. В чём разница? Фреймворк — 
это более сформированная методология со строгими правилами. В скраме все роли и процессы
чётко прописаны. Помимо Scrum, часто используют Kanban. 

Kanban
Сегодня это одна из наиболее популярных методологий разработки ПО.
Команда ведёт работу с помощью виртуальной доски, которая разбита на этапы проекта.
Каждый участник видит, какие задачи находятся в работе, какие — застряли на одном из
этапов, а какие уже дошли до его столбца и требуют внимания. 

В отличие от скрама, в канбане можно взять срочные задачи в разработку сразу,
не дожидаясь начала следующего спринта. 
Канбан удобно использовать не только в работе, но и в личных целях — распределять
собственные планы или задачи семьи на выходные, наглядно отслеживать прогресс.

//-----------

1) Конфигурация Git

Уровни конфигураций:

--system
--global ищет в --global потом в --system
--local (default) сначала ищет config local потом -global

git config user.name 'Oleg'

git config --global -e  - открыть редактирование файла конфигураций

.gitattributes - конфиг файл для работы с атрибутами в проекте.

.gitignore - конфиг файл, в котором шаблоны директориев на которые git не обращает внимание.

git check-ignore -v srcipts/for/one - проверяет среди всех шаблонов .gitignore проходит
такой путь или нет.

2) Основы Git 

Git имеет 3 состояния изменения файлов:

Рабочий каталог | Индексирование файлов | Репозиторий

git add . - внести все изменения
git status - посмотреть статус изменений
git commit -m 'коммит меседж' - коммит
git show - посмотреть детали коммита

комит без add

git commit -am 'Some commit' - не трогает новые файлы
alias.commitall '!git add .; git commit' создание алиаса

git rm <paths> - удаление файла
git rm -r src - удаление директории src
git mv index.html hello.html - переименование файла index.html -> hello.html

3) Ветки

git branch feature - создание новой ветки
git checkout feature - переходим на ветку

git branch -v - вывести состояние веток и последний коммит.

git checkout --force master - незакомиченные изменения будут утеряны
git stash - можно временно сохранить изменения перед тем как идти на другую ветку
git stash pop - вытащить эти изменения

git branch -f master коммитхэш/ветка - для того, чтобы ветка мастер 
перешла на старый коммит.

git branch -d fix - удаление ветки
git branch -D fix

git reflog master - логи ветки master
git reflog --date=iso

git gc - удалит недостяжимые коммиты

4) Теги Git

git tag v1.0.0 1943 - тег просто метка, он никуда не перемещается и указывает на один коммит.
git show --quiet v1.0.0

git tag - список тегов
git tag --contains 1943 - посмотреть список тегов, которые содержат коммит 1943

чтобы удалить Теги пишем

git tag -d название тегов - удаление тегов

git describe - найти ближайший тег

5) Reset в Git

git reset идентификатор коммита или '@~2'(на два коммита назад) - откатить на коммит
--hard
git reset --hard cvDqw1
git reset --hard ORIG_HEAD - вернуть всё как было, если нас не устроил ресет.
git reset --hard HEAD
--soft
git reset --soft cvDqw1
git commit --amend - правка последнего коммита. Откат ветки назад и создание нового коммита с
этими изменениями.
--mixed
git reset @~ - mixed - ресет по умолчанию.
--keep
git reset --keep - при жёстком reset, все незакоммиченные изменения удаляются, а keep старается
их сохранить. Reset --keep - это тот же жёсткий reset, но с сохранением незакоммиченных изменений.
--merge
git reset --merge - отмена неудачного конфликтного слияния.

6) Очистка проекта от изменений

git clean -dxf - удаление всех неотслеживаемых файлов и директорий.

7) Git просмотр

git diff master feature - сравнение коммитов.
git diff master...feature - если мы хотим узнать, что изменилось в feature 

8) Git слияние

git merge master - слияние ветки с master
git merge --abort
для отката слияния: 
git reset --hard @~ - если допустим хотим отменить merge и вернуться на предыдущий коммит.

Merge Strategy:
* recursive
* octopus
* ours 
* resolve
* subtree

9) Копирование коммитов.

git cherry-pick commit - копирование коммитов, делает с помощью cherry-pick
git cherry-pick --abort - отменит черипик и вернёт коммиты.
git cherry-pick --quit - прекращаем выполнение черипик.


10) Перемещение коммитов.

git rebase master - перемещение нашей ветки в мастер.
git rebase --abort
git rebase --quit

другой вариант записи:
git rebase --onto master feature - говорим, что мы хотим перебазировать ветку на мастер и ука-
зываем с какого момента.

11) Обратные коммиты.

git revert - делает коммит с противоположенными изменениями, для отмены коммита.

//-----------

Событие – это сигнал от браузера о том, что что-то произошло. 
Все DOM-узлы подают такие сигналы (хотя события бывают и не только в DOM).

События мыши:

click – происходит, когда кликнули на элемент левой кнопкой мыши (на устройствах с сенсорными 
экранами оно происходит при касании).
mouseover / mouseout – когда мышь наводится на / покидает элемент.
mousedown / mouseup – когда нажали / отжали кнопку мыши на элементе.
mousemove – при движении мыши.

События на элементах управления:

submit – пользователь отправил форму <form>.
focus – пользователь фокусируется на элементе, например нажимает на <input>.
Клавиатурные события:

keydown и keyup – когда пользователь нажимает / отпускает клавишу.

События документа:

DOMContentLoaded – когда HTML загружен и обработан, DOM документа полностью построен и доступен.

Событию можно назначить обработчик, то есть функцию, которая сработает, как только событие 
произошло. Именно благодаря обработчикам JavaScript-код может реагировать на действия 
пользователя. Есть несколько способов назначить событию обработчик. Сейчас мы их рассмотрим, 
начиная с самого простого.

- Использование атрибута HTML
Обработчик может быть назначен прямо в разметке, в атрибуте, который называется on<событие>.
<input value="Нажми меня" onclick="alert('Клик!')" type="button">

- Использование свойства DOM-объекта
Можно назначать обработчик, используя свойство DOM-элемента on<событие>.

К примеру, elem.onclick:

<input id="elem" type="button" value="Нажми меня!">
<script>
  elem.onclick = function() {
    alert('Спасибо');
  };
</script>

Назначить более одного обработчика событий таким способом нельзя.
Разработчики стандартов достаточно давно это поняли и предложили альтернативный способ назначения 
обработчиков при помощи специальных методов addEventListener и removeEventListener. 
Они свободны от указанного недостатка.

element.addEventListener(event, handler[, options]);
element.removeEventListener(event, handler[, options]);
event - имя события, например "click".
handler - ссылка на функцию-обработчик.
options - дополнительный объект со свойствами.

Чтобы хорошо обработать событие, могут понадобиться детали того, что произошло. Не просто «клик» 
или «нажатие клавиши», а также – какие координаты указателя мыши, какая клавиша нажата и 
так далее.

Когда происходит событие, браузер создаёт объект события, записывает в него детали и 
передаёт его в качестве аргумента функции-обработчику.

пример input, в котором мы берём event.targetValue

Мы можем назначить обработчиком не только функцию, но и объект при помощи addEventListener. 
В этом случае, когда происходит событие, вызывается метод объекта handleEvent.

К примеру:

<button id="elem">Нажми меня</button>

<script>
  elem.addEventListener('click', {
    handleEvent(event) {
      alert(event.type + " на " + event.currentTarget);
    }
  });
</script>

Всплытие и погружение

Стандарт DOM Events описывает 3 фазы прохода события:

Фаза погружения (capturing phase) – событие сначала идёт сверху вниз.
Фаза цели (target phase) – событие достигло целевого(исходного) элемента.
Фаза всплытия (bubbling stage) – событие начинает всплывать.

Всплытие - это когда на каком-либо элементе происходит событие, обработчики сначала 
срабатывают на нём, потом на его родителе, затем выше и так далее, вверх по цепочке предков.

Для того, чтобы остановить эффект всплытия используется event.stopPropagation(). После того
как мы добавим его. Событие не будет распространяться дальше.

Чтобы поймать событие на стадии погружения, нужно использовать третий аргумент capture вот так:

elem.addEventListener(..., {capture: true})
// или просто "true", как сокращение для {capture: true}
elem.addEventListener(..., true)
Существуют два варианта значений опции capture:

Если аргумент false (по умолчанию), то событие будет поймано при всплытии.
Если аргумент true, то событие будет перехвачено при погружении.
