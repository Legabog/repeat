Паттерн проектирования - какая-то концепция решения определённой проблемы.

Для чего вообще паттерны?

- Проверенные решения. Вы тратите меньше времени, используя готовые решения, вместо повторного 
изобретения велосипеда. До некоторых решений вы смогли бы додуматься и сами, но многие могут 
быть для вас открытием.

- Стандартизация кода. Вы делаете меньше просчётов при проектировании, используя типовые 
унифицированные решения, так как все скрытые проблемы в них уже давно найдены.

- Общий программистский словарь. Вы произносите название паттерна, вместо того, чтобы час 
объяснять другим программистам, какой крутой дизайн вы придумали и какие классы для этого нужны.

Классификация паттернов:

* Порождающие паттерны беспокоятся о гибком создании объектов без внесения в программу 
лишних зависимостей.

* Структурные паттерны показывают различные способы построения связей между объектами.

* Поведенческие паттерны заботятся об эффективной коммуникации между объектами.

Порождающие:

1.Одиночка(Singleton) - это порождающий паттерн проектирования, который гарантирует, у класса 
есть только один экземпляр, и предоставляет к нему глобальную точку доступа. Одиночка решает
сразу две проблемы, нарушая принцип еднственной ответственности класса. Нарушает SOLID - Sinlge
responsibility principle, так как является God object.

1) Гарантирует наличие единственного экземпляра класса.
2) Предоставляет глобальную точку доступа.

Обычно одиночки не имеют глобального конструктора, который можно получить. Вместо этого обычно у
одиночки есть метод(интерфейс), вызвав который можно получить данные.
Одиночку никогда не заменит другой код, существует только один экзмепляр этого клсса.

Плюсы:
- Гарантирует наличие единственного экземпляра класса.
- Предоставляет к нему глобальную точку доступа.
Минусы:
- Нарушает SOLID
- Маскирует плохой дизайн.

2.Строитель(Builder) - это порождающий паттерн проектирования, который позволяет создавать 
сложные объекты пошагово. Строитель даёт возможность использовать один и тот же код строительства
для получения разных представлений объектов.

Сам паттерн предлагает разделить процесс на подпроцессы и создать объект строитель для каждого
подпроцесса. Чтобы полностью создать объект, нам придётся вызывать поочерёдно вызовы строите-
лей. Часто бывает, что нам необходимо несколько вызывать вариантов стрителей, в зависимости от
поставленной задачи. Мы с лёгкостью может добавить вариативных строителей и вынести их вызовы
в отдельный класс, Директор. В этом случае директор будет заниматься вызовами строителей, 
строитель будет их выполнять. Получится отличный сплит обязанностей.
Такая структура будет будет скрывать полностью процесс конструирования объектов.

Плюсы:
- Поэтапное создание продукта.
- Переиспользование одного и того же кода.
- Изолирует код реализации от кода сборки.
Минусы:
- Усложняет код программы из-за введения дополнительный классов.

Структурные:

1.Адаптер(Adapter) - паттерн основанный на преобразовании объектов к единому виду, для 
совместной работы. Адаптер - очень полезен, он выступает в качестве объекта переводчика 
и трансформирует интерфейс или данные одного объекта в такой вид, чтобы он стал понятен 
другому объекту.
Бывает также двухсторонний адаптер, который трансформирует в обе стороны. Допустим у нас есть
данные одного формата XML и нам надо привести всё к формату JSON. Адаптер отлично выполнит эту
работу. 

Плюсы:
- Отделяет и скрывает от клиента подробности преобразования различных интерфейсов.
Минусы:
- Усложняет код программы из-за введения дополнительных классов.

2.Заместитель(Proxy) - это структурный паттер, который позволяет подставлять вместо реальных 
объектов специальные объекты-заменители. Эти объекты перехватывают вызовы к оригинальному
объекту, позволяя что-то сделать до или после передачи вызова оригиналу.
С помощью этого паттерна можно с лёгкостью добавить какой-нибудь дополнительный слой логики.

Плюсы:
- Позволяет контролировать сервисный объект незаметно для клиента.
- Может работать, даже если сервисный объект ещё не создан.
- Может контролировать жизненный цикл служебного объекта.
Минусы:
- Усложняет код программы из-за введения дополнительных классов.
- Увеличивает время отклика от сервиса.

Поведенческие:

1.Наблюдатель(Observer) - это поведенческий паттерн, который создаёт механизм подписки, позволя-
ющий одним объектам следить и реагировать на события, происходящие в других объектах.

Сам по себе объект Observer должен подписывать кого-то на события. После этого с объектом, у 
которого подписка выполняются какие-либо действия.

Пример из жизни:
После того как вы оформили подписку на газету или журнал, вам больше не нужно ездить в 
супермаркет и проверять, не вышел ли очередной номер. Вместо этого издательство будет 
присылать новые номера по почте прямо к вам домой сразу после их выхода.

Издательство ведёт список подписчиков и знает, кому какой журнал высылать. Вы можете в 
любой момент отказаться от подписки, и журнал перестанет вам приходить.

Плюсы:
- Издатели не зависят от конкретных классов подписчиков и наоборот.
- Вы можете подписывать и отписывать получателей на лету.
- Реализует принцип открытости/закрытости.

Минусы:
- Подписчики оповещаются в случайном порядке.

2.Состояние(State) - это поведенческий паттерн проектирования, который позволяет объектам менять
поведение в зависимости от своего состояния. Извне создаётся впечатление, что изменился класс 
объекта.

Плюсы:
- Избавляет от множества больших условных операторов машины состояний.
- Концентрирует в одном месте код, связанный с определённым состоянием.
- Упрощает код контекста.
Минусы:
- Может неоправданно усложнить код, если состояний мало и они редко меняются.




